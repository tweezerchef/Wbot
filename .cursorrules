# Cursor AI Instructions for Wbot

This file provides instructions and context for Cursor AI when working on this project.

---

## Project Overview

Wbot is an AI wellness chatbot built as a monorepo with:

- **Web Frontend**: TanStack Start (React 19 + Vite 7)
- **AI Backend**: Python with LangGraph/LangChain
- **Database**: Supabase (PostgreSQL)

The chatbot is the PRIMARY interface - activities render inside the chat, not as separate pages.

---

## Critical Rules

### Git & Commits

- **NEVER** run `git add` or `git commit` without explicit user authorization
- **NEVER** include Claude credits, co-author tags, or AI attribution in commits
- **NEVER** push to remote without explicit permission
- Always show the user what will be committed before committing
- Use conventional commit messages (feat:, fix:, refactor:, docs:, etc.)

### Code Quality

- **ALWAYS** use latest best practices - check documentation and web sources when unsure
- **ALWAYS** research solutions using web search and official docs before implementing
- **ALWAYS** separate concerns with clear folder structure and descriptive filenames
- **ALWAYS** add comments explaining what code does and why
- **ALWAYS** use proper TypeScript types - avoid `any` and `unknown` where possible
- **NEVER** add unnecessary complexity or over-engineer solutions
- **NEVER** add features not explicitly requested

### Testing

#### âš ï¸ CRITICAL: Never Rewrite Tests to Make Them Pass

**Tests reveal bugs - FIX THE CODE, not the tests.**

- **NEVER** change tests to avoid failures - tests reveal bugs that need fixing
- **ALWAYS** fix code bugs when tests fail, not the tests themselves
- **ONLY** change failing tests if the issue is actually in the test (incorrect assertions, wrong mocks, etc.)
- **NEVER** weaken test assertions or add workarounds to make tests pass
- **NEVER** use `sys.modules` mocking or other hacks to work around import/code issues
- **NEVER** skip tests with `.skip()` or `@pytest.skip` to hide failures
- **NEVER** change expected values to match buggy output

**When tests fail, ask yourself:**

1. Is the test correct? (Does it test the right behavior?)
2. Is the implementation wrong? (Most likely - fix the code!)
3. Did requirements change? (Only then update the test, with user approval)

---

## Testing Tools & Commands

### Frontend (apps/web) - Vitest + Testing Library

| Package                       | Purpose                         | Usage                       |
| ----------------------------- | ------------------------------- | --------------------------- |
| `vitest`                      | Test runner (fast, Vite-native) | `pnpm test`                 |
| `@vitest/ui`                  | Interactive test browser UI     | `pnpm test:ui`              |
| `@vitest/coverage-v8`         | Code coverage reports           | `pnpm test:coverage`        |
| `@testing-library/react`      | React component testing         | Render and query components |
| `@testing-library/jest-dom`   | DOM assertion matchers          | `toBeInTheDocument()`, etc. |
| `@testing-library/user-event` | User interaction simulation     | `userEvent.click()`, etc.   |
| `happy-dom`                   | Fast DOM implementation         | Configured in vitest.config |

### Backend (apps/ai) - Pytest

| Package          | Purpose            | Usage                                 |
| ---------------- | ------------------ | ------------------------------------- |
| `pytest`         | Testing framework  | `uv run pytest`                       |
| `pytest-asyncio` | Async test support | Automatic via `asyncio_mode = "auto"` |
| `pytest-mock`    | Mocking utilities  | `mocker` fixture                      |

### Testing Commands

```bash
# Frontend (apps/web)
pnpm test                      # Run all tests in watch mode
pnpm test:ui                   # Open interactive Vitest UI
pnpm test:coverage             # Run tests with coverage report
pnpm test ComponentName        # Run specific test file
pnpm --filter @wbot/web test   # Run from monorepo root

# Backend (apps/ai)
cd apps/ai && uv run pytest              # Run all Python tests
cd apps/ai && uv run pytest -v           # Verbose output
cd apps/ai && uv run pytest tests/test_file.py  # Run specific file
cd apps/ai && uv run pytest -k "test_name"      # Run tests matching pattern
```

---

## Project Structure

```
apps/
â”œâ”€â”€ web/src/
â”‚   â”œâ”€â”€ routes/          # File-based routing (TanStack Router)
â”‚   â”œâ”€â”€ components/      # Reusable UI components
â”‚   â”‚   â”œâ”€â”€ pages/       # Page-level components (ChatPage, LandingPage, SignupPage)
â”‚   â”‚   â”œâ”€â”€ BreathingExercise/  # Interactive breathing activity
â”‚   â”‚   â”œâ”€â”€ GuidedMeditation/   # Meditation components
â”‚   â”‚   â”œâ”€â”€ ImmersiveBreathing/ # Full-screen breathing experience
â”‚   â”‚   â”œâ”€â”€ ConversationHistory/  # Sidebar conversation panel
â”‚   â”‚   â”œâ”€â”€ buttons/     # Icon button components
â”‚   â”‚   â””â”€â”€ ComponentName/
â”‚   â”‚       â”œâ”€â”€ ComponentName.tsx
â”‚   â”‚       â””â”€â”€ ComponentName.module.css
â”‚   â”œâ”€â”€ lib/             # Utility modules and clients
â”‚   â”‚   â”œâ”€â”€ supabase.ts  # Supabase client
â”‚   â”‚   â”œâ”€â”€ ai-client.ts # LangGraph SDK client
â”‚   â”‚   â”œâ”€â”€ conversations.ts     # Conversation CRUD
â”‚   â”‚   â”œâ”€â”€ conversationHistory.ts  # History utilities
â”‚   â”‚   â””â”€â”€ parseActivity.ts     # Activity parsing
â”‚   â”œâ”€â”€ styles/          # Global styles and CSS variables
â”‚   â””â”€â”€ types/           # TypeScript type definitions
â”‚
â”œâ”€â”€ ai/src/
â”‚   â”œâ”€â”€ graph/           # LangGraph definitions (state.py, wellness.py)
â”‚   â”œâ”€â”€ nodes/           # One folder per node
â”‚   â”‚   â”œâ”€â”€ generate_response/   # Main response generation
â”‚   â”‚   â”œâ”€â”€ detect_activity/     # Activity detection
â”‚   â”‚   â”œâ”€â”€ breathing_exercise/  # Breathing activity
â”‚   â”‚   â”œâ”€â”€ meditation_guidance/ # Meditation activity
â”‚   â”‚   â”œâ”€â”€ journaling_prompt/   # Journaling activity
â”‚   â”‚   â”œâ”€â”€ analyze_profile/     # User profiling
â”‚   â”‚   â”œâ”€â”€ retrieve_memories/   # Semantic memory retrieval
â”‚   â”‚   â””â”€â”€ store_memory/        # Memory persistence
â”‚   â”œâ”€â”€ memory/          # Semantic memory system
â”‚   â”‚   â”œâ”€â”€ cache.py     # Redis embedding cache
â”‚   â”‚   â”œâ”€â”€ embeddings.py  # Vector embeddings
â”‚   â”‚   â””â”€â”€ store.py     # Memory storage
â”‚   â”œâ”€â”€ prompts/         # System prompts and templates
â”‚   â”œâ”€â”€ llm/             # LLM provider configurations
â”‚   â”œâ”€â”€ tts/             # Text-to-speech generation
â”‚   â””â”€â”€ utils/           # Utility functions
â”‚
packages/
â”œâ”€â”€ shared/src/          # Shared TypeScript types
â”‚   â””â”€â”€ types/           # Database types, API types, etc.
â””â”€â”€ storybook/           # Component documentation
```

---

## Naming Conventions

| Type             | Convention                  | Example                  |
| ---------------- | --------------------------- | ------------------------ |
| React Components | PascalCase                  | `ChatMessage.tsx`        |
| CSS Modules      | camelCase                   | `ChatMessage.module.css` |
| Hooks            | camelCase with `use` prefix | `useAuth.ts`             |
| Utilities        | camelCase                   | `formatDate.ts`          |
| Routes           | kebab-case                  | `sign-up.tsx`            |
| Python modules   | snake_case                  | `generate_response.py`   |
| Python classes   | PascalCase                  | `WellnessState`          |
| Environment vars | SCREAMING_SNAKE_CASE        | `VITE_SUPABASE_URL`      |

---

## Tech Stack Reference

### Frontend

- **Framework**: TanStack Start v1.145+
- **React**: v19
- **Vite**: v7
- **Routing**: TanStack Router (file-based)
- **Styling**: CSS Modules + CSS Variables
- **State**: TanStack Query + React hooks
- **Auth Client**: Supabase JS v2
- **Validation**: Zod (required for all data validation)
- **Animation**: Framer Motion

### Backend

- **Runtime**: Python 3.11+
- **Framework**: LangGraph + LangChain
- **LLM**: Anthropic Claude (primary), Google Gemini (experimental)
- **Memory**: Semantic memory with vector embeddings
- **Cache**: Upstash Redis (remote) for embedding cache
- **Package Manager**: uv
- **Linting**: Ruff
- **API**: FastAPI + Uvicorn

### Database

- **Platform**: Supabase (PostgreSQL) - Remote hosted
- **Auth**: Supabase Auth
- **Security**: Row Level Security (RLS) enabled
- **Migrations**: `supabase/migrations/` pushed via `pnpm db:push`

---

## Common Commands

```bash
# Development (start everything - uses remote Supabase & Upstash Redis)
pnpm dev:all              # Start web + AI (no Docker required)
pnpm dev:web              # Start web frontend only
pnpm dev:ai               # Start AI backend only

# Storybook
pnpm storybook            # Start Storybook dev server

# Documentation
pnpm docs                 # Start docs dev server

# Database (remote Supabase)
pnpm db:push              # Push migrations to remote Supabase
pnpm db:generate-types    # Generate TypeScript types from remote DB
pnpm db:status            # Check migration status
pnpm db:new <name>        # Create new migration file

# Building
pnpm build                # Build all packages

# Linting & Formatting
pnpm lint                 # Lint all packages (ESLint 9)
pnpm lint:fix             # Lint with auto-fix
pnpm format               # Format all files with Prettier
pnpm format:check         # Check formatting without fixing
cd apps/ai && uv run ruff check .   # Lint Python
cd apps/ai && uv run ruff format .  # Format Python
```

---

## Package Management (pnpm Monorepo)

This is a pnpm workspace monorepo. Follow these patterns:

```bash
# To workspace root (shared dev tools like ESLint, Prettier)
pnpm add -wD <package>

# To a specific app/package
pnpm add <package> --filter @wbot/web
pnpm add -D <package> --filter @wbot/shared

# ALWAYS run install after adding packages to sync lockfile
pnpm install
```

**Important Rules:**
- **ALWAYS** run `pnpm install` after adding packages to ensure lockfile is synced
- **NEVER** use npm or yarn - this project uses pnpm exclusively
- **NEVER** install packages globally - add them as project dependencies
- Use `-w` flag for workspace root, `--filter` for specific packages

---

## TypeScript Typing Rules

- **NEVER** use `any` - define proper types or interfaces
- **AVOID** `unknown` - prefer specific types; use type guards when needed
- **ALWAYS** type function parameters and return types
- **PREFER** inferring types from Zod schemas with `z.infer<typeof schema>`
- **USE** the shared types from `@wbot/shared` for database entities
- Generate database types with `pnpm db:generate-types` after schema changes

---

## Library Preferences

- **ALWAYS** prefer TanStack libraries over alternatives:
  - TanStack Query over Zustand/Redux for state management
  - TanStack Router (already in use via TanStack Start)
  - TanStack Table for data tables (if needed)
- This ensures consistency with the TanStack Start architecture

---

## CSS Guidelines

### Use CSS Variables

All colors, spacing, and typography should use variables from `variables.css`:

```css
.container {
  background: var(--color-background);
  padding: var(--spacing-md);
  border-radius: var(--radius-md);
}
```

### CSS Module Naming

Use camelCase for class names in CSS Modules:

```css
/* Good */
.messageContainer { }
.userMessage { }

/* Avoid */
.message-container { }
.user_message { }
```

---

## Zod Validation Guidelines

**ALWAYS use Zod for data validation.** This includes:

- API response validation
- Form input validation
- Environment variable validation
- Props validation (when complex)
- Any external data parsing

### Example Usage

```tsx
import { z } from 'zod';

// Define the schema
export const userSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  displayName: z.string().min(1).max(100).optional(),
});

// Infer TypeScript type from schema
export type User = z.infer<typeof userSchema>;

// Use for validation
const result = userSchema.safeParse(data);
if (!result.success) {
  console.error('Validation failed:', result.error.flatten());
}
```

---

## Python Logging Guidelines

All Python nodes use the `NodeLogger` class for clean, minimal output:

```python
from src.logging_config import NodeLogger

# Create logger with node name
logger = NodeLogger("my_node")

# Node lifecycle - automatic visual separators
logger.node_start()   # Shows: â–¶ MY_NODE
logger.node_end()     # Shows: âœ“ MY_NODE

# Logging with context (appears on separate lines)
logger.info("Activity detected",
    activity="breathing",
    confidence="85%"
)
```

### What Gets Logged

**DO log:**
- Node entry/exit (using `node_start()` / `node_end()`)
- Key decisions (routing choices, technique selections)
- Important context (memory usage, user choices)
- Errors and warnings

**DON'T log:**
- Verbose details like full message previews
- Redundant information already in context
- Step-by-step progress within a node

---

## MCP Integrations

This project uses Model Context Protocol (MCP) servers to enhance AI capabilities.

### Storybook MCP

When Storybook is running (`pnpm storybook`), you have access to component documentation via MCP.

**Available Tools:**
- `list-all-components` - List all UI components in the Storybook library
- `get-component-documentation` - Get detailed props and docs for a component
- `get-story-urls` - Get URLs for specific component stories
- `get-ui-building-instructions` - Get instructions for UI component development

**When to Use:**
- **ALWAYS** call `get-ui-building-instructions` before creating or modifying UI components
- Use `list-all-components` to discover existing components before creating new ones
- Use `get-component-documentation` to understand component APIs and usage patterns

---

## Key Files Reference

| Purpose            | File Path                                    |
| ------------------ | -------------------------------------------- |
| Root layout        | `apps/web/src/routes/__root.tsx`             |
| Router config      | `apps/web/src/router.tsx`                    |
| Chat page          | `apps/web/src/components/pages/ChatPage/`    |
| Breathing activity | `apps/web/src/components/BreathingExercise/` |
| Conversations      | `apps/web/src/lib/conversations.ts`          |
| Supabase client    | `apps/web/src/lib/supabase.ts`               |
| AI client          | `apps/web/src/lib/ai-client.ts`              |
| CSS variables      | `apps/web/src/styles/variables.css`          |
| AI graph           | `apps/ai/src/graph/wellness.py`              |
| Graph state        | `apps/ai/src/graph/state.py`                 |
| Memory system      | `apps/ai/src/memory/`                        |
| System prompt      | `apps/ai/src/prompts/wellness_system.py`     |
| DB migrations      | `supabase/migrations/*.sql`                  |
| Shared types       | `packages/shared/src/types/*.ts`             |
| Roadmap            | `docs/ROADMAP.md`                            |
| Internal docs      | `docs/`                                      |

---

## Development Guidelines

### Adding a New Route

1. Create file in `apps/web/src/routes/` (e.g., `settings.tsx`)
2. Use `createFileRoute` from TanStack Router
3. Create corresponding `.module.css` file for styles
4. Route is automatically registered by file-based routing

### Adding a New Component

1. Create folder in `apps/web/src/components/ComponentName/`
2. Create `ComponentName.tsx` and `ComponentName.module.css`
3. Use named exports
4. Add prop types with JSDoc comments

### Adding a New LangGraph Node

1. Create folder in `apps/ai/src/nodes/node_name/`
2. Create `node.py` with the node function
3. Register node in `apps/ai/src/graph/wellness.py`
4. Reference existing nodes for patterns:
   - `generate_response/` - Claude integration with streaming
   - `retrieve_memories/` - Semantic memory retrieval
   - `breathing_exercise/` - Activity generation

### Adding a New Interactive Activity

1. Create component folder in `apps/web/src/components/ActivityName/`
2. Reference `BreathingExercise/` for patterns:
   - Main component with activity logic
   - Animation component (if needed)
   - Custom hooks for audio/timing
   - CSS module for styling
3. Create corresponding node in `apps/ai/src/nodes/activity_name/`
4. Update `parseActivity.ts` to handle the new activity type

### Adding Database Tables

1. Create new migration file: `pnpm db:new <name>`
2. Write SQL in `supabase/migrations/`
3. Include RLS policies for security
4. Push to remote: `pnpm db:push`
5. Generate types: `pnpm db:generate-types`

---

## Environment Variables

### Web App (apps/web/.env)

Variables must have `VITE_` prefix to be exposed to client:

```bash
VITE_SUPABASE_URL=        # Supabase project URL
VITE_SUPABASE_ANON_KEY=   # Supabase anonymous key
VITE_LANGGRAPH_API_URL=   # LangGraph API endpoint
```

### AI Backend (apps/ai/.env)

```bash
ANTHROPIC_API_KEY=        # Claude API key
GOOGLE_API_KEY=           # Gemini API key (optional)
SUPABASE_URL=             # For token validation
SUPABASE_SERVICE_KEY=     # Service role key (server only)
```

---

## Error Handling

### Frontend
- Use error boundaries for component-level errors
- Show user-friendly error messages
- Log errors to console in development
- Gracefully handle network failures

### Backend
- Return structured error responses
- Log errors with context
- Never expose internal errors to clients
- Handle LLM API rate limits gracefully

---

## Security Reminders

- Never expose `SUPABASE_SERVICE_KEY` to the client
- Always use RLS policies for database access
- Validate user input on both client and server
- Sanitize content before rendering
- Use HTTPS in production

---

## Internal Documentation

Project documentation is stored in the `docs/` folder and its subfolders. **ALWAYS** refer to these internal docs when:

- Understanding project architecture or design decisions
- Looking for feature specifications or requirements
- Checking implementation details or patterns specific to this project
- Researching how existing features were built

Before implementing new features or making significant changes, check if relevant documentation exists in `docs/`.

---

## Current Development Status

**Completed Phases:**
- âœ… Phase 1: Core Authentication Flow
- âœ… Phase 2: Chat Interface
- âœ… Phase 3: AI Backend Implementation
- ğŸ”„ Phase 4: Interactive Activities (In Progress)

**Current Focus:**
- Breathing exercises with audio cues âœ…
- Meditation guidance (in progress)
- Journaling prompts
- Activity history tracking

See `docs/ROADMAP.md` for full details.

---

_This file helps Cursor AI understand the project conventions and constraints._

_Last updated: January 6, 2025_
