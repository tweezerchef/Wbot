/**
 * useConversationMessages Hook
 *
 * Manages conversation messages using TanStack Query cache as the source of truth.
 *
 * This hook provides:
 * - Messages state that syncs with the Query cache
 * - Streaming content state for SSE real-time updates
 * - addMessage function to update cache and trigger re-renders
 * - setMessages function for bulk updates
 *
 * Benefits over useState:
 * - Other components can access messages from cache
 * - Automatic cache invalidation integration
 * - Better consistency across the app
 */

import { useQueryClient } from '@tanstack/react-query';
import { useCallback, useState, useMemo } from 'react';

import type { Message } from '@/lib/ai-client';
import { conversationMessagesOptions, type MessageRow } from '@/lib/queries';

/* ----------------------------------------------------------------------------
   Type Conversions
   ---------------------------------------------------------------------------- */

/**
 * Convert a Message to a MessageRow for cache storage
 */
function messageToRow(message: Message, conversationId: string): MessageRow {
  return {
    id: message.id,
    conversation_id: conversationId,
    role: message.role,
    content: message.content,
    created_at:
      message.createdAt instanceof Date ? message.createdAt.toISOString() : message.createdAt,
    metadata: null,
    search_vector: null, // Generated by database, not needed for cache
  };
}

/**
 * Convert a MessageRow from cache to a Message
 */
function rowToMessage(row: MessageRow): Message {
  return {
    id: row.id,
    role: row.role as 'user' | 'assistant',
    content: row.content,
    createdAt: row.created_at ? new Date(row.created_at) : new Date(),
  };
}

/* ----------------------------------------------------------------------------
   Hook Interface
   ---------------------------------------------------------------------------- */

interface UseConversationMessagesOptions {
  /** Initial messages from loader (used to seed cache if empty) */
  initialMessages: Message[];
  /** Current conversation ID (null if no conversation) */
  conversationId: string | null;
}

interface UseConversationMessagesReturn {
  /** Current messages from cache */
  messages: Message[];
  /** Current streaming content (partial AI response) */
  streamingContent: string;
  /** Set streaming content during SSE */
  setStreamingContent: (content: string) => void;
  /** Add a single message to the cache */
  addMessage: (message: Message) => void;
  /** Add user message (convenience method that also adds to optimistic UI) */
  addUserMessage: (content: string, id?: string) => Message;
  /** Clear all messages (for new conversation) */
  clearMessages: () => void;
  /** Bulk set messages (for conversation switch) */
  setMessages: (messages: Message[]) => void;
}

/* ----------------------------------------------------------------------------
   Hook Implementation
   ---------------------------------------------------------------------------- */

export function useConversationMessages({
  initialMessages,
  conversationId,
}: UseConversationMessagesOptions): UseConversationMessagesReturn {
  const queryClient = useQueryClient();

  // Streaming content for real-time AI responses
  const [streamingContent, setStreamingContent] = useState('');

  // Get the query key for the current conversation
  const queryKey = conversationId ? conversationMessagesOptions(conversationId).queryKey : null;

  // Get messages from cache, falling back to initial messages
  const cachedData = queryKey ? queryClient.getQueryData<MessageRow[]>(queryKey) : null;

  // Convert cached rows to Messages, or use initial messages if cache is empty
  const messages = useMemo(() => {
    if (cachedData && cachedData.length > 0) {
      return cachedData.map(rowToMessage);
    }
    return initialMessages;
  }, [cachedData, initialMessages]);

  // Add a single message to the cache
  const addMessage = useCallback(
    (message: Message) => {
      if (!conversationId || !queryKey) {
        return;
      }

      queryClient.setQueryData<MessageRow[]>(queryKey, (old) => {
        const existingRows = old ?? [];
        const newRow = messageToRow(message, conversationId);

        // Check if message already exists (avoid duplicates)
        if (existingRows.some((r) => r.id === newRow.id)) {
          return existingRows;
        }

        return [...existingRows, newRow];
      });
    },
    [queryClient, queryKey, conversationId]
  );

  // Convenience method to add a user message
  const addUserMessage = useCallback(
    (content: string, id?: string): Message => {
      const message: Message = {
        id: id ?? `user-${String(Date.now())}`,
        role: 'user',
        content,
        createdAt: new Date(),
      };
      addMessage(message);
      return message;
    },
    [addMessage]
  );

  // Clear all messages (for new conversation)
  const clearMessages = useCallback(() => {
    if (!queryKey) {
      return;
    }
    queryClient.setQueryData<MessageRow[]>(queryKey, []);
  }, [queryClient, queryKey]);

  // Bulk set messages (for conversation switch)
  const setMessages = useCallback(
    (newMessages: Message[]) => {
      if (!conversationId || !queryKey) {
        return;
      }

      queryClient.setQueryData<MessageRow[]>(
        queryKey,
        newMessages.map((m) => messageToRow(m, conversationId))
      );
    },
    [queryClient, queryKey, conversationId]
  );

  return {
    messages,
    streamingContent,
    setStreamingContent,
    addMessage,
    addUserMessage,
    clearMessages,
    setMessages,
  };
}
